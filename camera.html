<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magic Note Pro</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; touch-action: none; }
        #setup-screen { position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; background: #1a1a1a; }
        button { padding: 15px 30px; font-size: 18px; cursor: pointer; border-radius: 10px; border: none; background: #444; color: white; margin-top: 20px; }

        /* 偽裝黑屏 */
        #black-screen { 
            position: fixed; inset: 0; background: #000; z-index: 50; display: none; 
            cursor: pointer; /* 點擊黑屏可以強制返回，預防感應器卡住 */
        }

        /* 繪圖介面 */
        #draw-screen { position: fixed; inset: 0; background: #fff; z-index: 10; display: block; }
        canvas { width: 100%; height: 100%; touch-action: none; }
        
        /* 偷看視窗：調低透明度，放在不容易被觀眾手指遮住的地方 */
        #peek-video { 
            position: absolute; 
            bottom: 10px; 
            right: 10px; 
            width: 100px; 
            height: auto; 
            opacity: 0.2; 
            pointer-events: none;
            z-index: 60;
            transform: scaleX(-1);
        }
        
        #debug-info { position: fixed; top: 5px; left: 5px; font-size: 10px; color: #ccc; z-index: 70; pointer-events: none; }
    </style>
</head>
<body>

    <div id="setup-screen">
        <h3>Magic System Setup</h3>
        <button onclick="initMagic()">Initialize Sensors</button>
    </div>

    <div id="black-screen" onclick="forceStop()"></div>

    <div id="draw-screen">
        <div id="debug-info">Status: Standby</div>
        <video id="peek-video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        let mediaRecorder;
        let chunks = [];
        let isRecording = false;
        const peekVideo = document.getElementById('peek-video');
        const blackScreen = document.getElementById('black-screen');
        const debugInfo = document.getElementById('debug-info');
        let stream;

        async function initMagic() {
            try {
                // 1. 獲取相機流
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment", width: 640, height: 480 }, 
                    audio: false 
                });
                peekVideo.srcObject = stream;
                
                // 2. 請求 iOS/Android 感應器權限
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    await DeviceOrientationEvent.requestPermission();
                }

                window.addEventListener('deviceorientation', handleMotion);
                document.getElementById('setup-screen').style.display = 'none';
                initCanvas();
                debugInfo.innerText = "Status: Ready";
            } catch (err) {
                alert("Error: " + err.message);
            }
        }

        function handleMotion(event) {
            let beta = event.beta; 
            
            // 邏輯修正：當 Beta 絕對值大於 160 度（螢幕朝下）
            if (Math.abs(beta) > 160) {
                if (!isRecording) {
                    startRecording();
                }
            } else if (Math.abs(beta) < 40) {
                // 手機拿平或直立時（螢幕朝上）
                if (isRecording) {
                    stopRecording();
                }
            }
        }

        function startRecording() {
            if (isRecording) return;
            isRecording = true;
            chunks = [];
            
            // 重新連接相機流以確保畫面是即時的
            peekVideo.srcObject = stream;
            peekVideo.play();

            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.ondataavailable = e => chunks.push(e.data);
            mediaRecorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const videoURL = URL.createObjectURL(blob);
                peekVideo.srcObject = null; // 切換從 Blob 讀取
                peekVideo.src = videoURL;
                peekVideo.loop = true;
                peekVideo.play();
            };
            
            mediaRecorder.start();
            blackScreen.style.display = 'block';
            debugInfo.innerText = "Status: RECORDING...";
            debugInfo.style.color = "red";
        }

        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
            }
            blackScreen.style.display = 'none';
            debugInfo.innerText = "Status: PLAYING VOD";
            debugInfo.style.color = "blue";
        }

        function forceStop() {
            stopRecording();
        }

        function initCanvas() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            let drawing = false;
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#000';

            const getPos = (e) => {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: (e.touches ? e.touches[0].clientX : e.clientX) - rect.left,
                    y: (e.touches ? e.touches[0].clientY : e.clientY) - rect.top
                };
            };

            const start = (e) => { drawing = true; ctx.beginPath(); const p = getPos(e); ctx.moveTo(p.x, p.y); };
            const move = (e) => { if(!drawing) return; const p = getPos(e); ctx.lineTo(p.x, p.y); ctx.stroke(); };
            const stop = () => { drawing = false; };

            canvas.addEventListener('touchstart', start);
            canvas.addEventListener('touchmove', move);
            canvas.addEventListener('touchend', stop);
        }
    </script>
</body>
</html>